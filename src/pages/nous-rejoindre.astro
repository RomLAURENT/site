---
import type { LieuHierarchique, GeolienEntry, GeolienData, ProcessedGeolien } from '../types/geoliens';
import geolienData from './_geolieu.json';
import '../styles/app.css';
import SearchForm from '../components/SearchForm.astro';
import ViewToggle from '../components/ViewToggle.astro';
import GeolienGrid from '../components/GeolienGrid.astro';
import MapView from '../components/MapView.astro';

const geolienDataTyped = geolienData as GeolienData;
const rawData = [...geolienDataTyped.reseaux, ...geolienDataTyped.regions];

// Fonction utilitaire pour vérifier si une entrée est un lieu hiérarchique
function isLieuHierarchique(entry: GeolienEntry): entry is LieuHierarchique {
	const hasLiens = 'liens' in entry && Array.isArray((entry as LieuHierarchique).liens);
	const hasNomOnly = !('type' in entry) && !('url' in entry) && 'nom' in entry;
	return hasLiens && hasNomOnly;
}

// Fonction utilitaire pour aplatir la structure de données avec gestion de la hiérarchie
function flattenGeoliens(data: GeolienEntry[], parentPath: string = ''): ProcessedGeolien[] {
	const result: ProcessedGeolien[] = [];

	data.forEach((entry) => {
		if (isLieuHierarchique(entry)) {
			// Construire le chemin hiérarchique complet
			const currentPath = parentPath ? `${parentPath} > ${entry.nom}` : entry.nom;

			// Gérer les entrées hiérarchiques et ajouter leurs liens
			if (entry.liens && entry.liens.length > 0) {
				entry.liens.forEach(lien => {
					result.push({
						...lien,
						lieuNom: entry.nom,
						fullPath: currentPath
					});
				});
			}

			// Gérer récursivement les sousLieux avec le chemin mis à jour
			if (entry.sousLieux && entry.sousLieux.length > 0) {
				result.push(...flattenGeoliens(entry.sousLieux, currentPath));
			}
		} else {
			// Gérer les entrées plates (liens directs) - celles-ci sont au niveau racine
			result.push({
				...entry,
				fullPath: parentPath || 'Root'
			});
		}
	});

	return result;
}

const geoliens = flattenGeoliens(rawData);
---
<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nous Rejoindre - Trouver un groupe près de chez vous</title>
</head>
<body class="bg-neutral-dark min-h-screen font-theme" >
	<div class="container mx-auto px-4 py-8">
		<header class="mb-8">
			<h1 class="text-2xl font-bold text-neutral-dark mb-4">Nous Rejoindre</h1>
			<p class="text-sm font-medium text-neutral-medium mb-6">Trouvez un groupe près de chez vous ou qui correspond à vos centres d'intérêt</p>
		</header>

		<ViewToggle />

		<SearchForm resultsCount={geoliens.length} />

		<GeolienGrid geoliens={geoliens} />

		<MapView />
	</div>

	<script is:inline define:vars={{ geoliens }}>

		// DOM elements
		const listViewBtn = document.getElementById('list-view-btn');
		const mapViewBtn = document.getElementById('map-view-btn');
		const listView = document.getElementById('list-view');
		const mapView = document.getElementById('map-view');
		const searchText = document.getElementById('search-text');
		const searchType = document.getElementById('search-type');
		const searchTerritoire = document.getElementById('search-territoire');
		const searchLocation = document.getElementById('search-location');
		const clearFiltersBtn = document.getElementById('clear-filters');
		const resultsCount = document.getElementById('results-count');
		const geolienCards = document.querySelectorAll('.geolien-card');
		const noResults = document.getElementById('no-results');

		// View switching
		function switchToListView() {
			listView.classList.remove('hidden');
			mapView.classList.add('hidden');
			listViewBtn.classList.add('bg-blue-600', 'text-white');
			listViewBtn.classList.remove('bg-gray-200', 'text-gray-700');
			mapViewBtn.classList.remove('bg-blue-600', 'text-white');
			mapViewBtn.classList.add('bg-gray-200', 'text-gray-700');
		}

		function switchToMapView() {
			listView.classList.add('hidden');
			mapView.classList.remove('hidden');
			mapViewBtn.classList.add('bg-blue-600', 'text-white');
			mapViewBtn.classList.remove('bg-gray-200', 'text-gray-700');
			listViewBtn.classList.remove('bg-blue-600', 'text-white');
			listViewBtn.classList.add('bg-gray-200', 'text-gray-700');
		}

		listViewBtn.addEventListener('click', switchToListView);
		mapViewBtn.addEventListener('click', switchToMapView);

		// Filtering function
		function filterResults() {
			const searchQuery = searchText.value.toLowerCase().trim();
			const selectedType = searchType.value;
			const selectedTerritoire = searchTerritoire.value;
			const locationQuery = searchLocation.value.toLowerCase().trim();

			let visibleCount = 0;

			geolienCards.forEach(card => {
				const cardNom = card.dataset.nom;
				const cardType = card.dataset.type;
				const cardTerritoire = card.dataset.territoire;
				const cardLieu = card.dataset.lieu;
				const cardFullPath = card.dataset.fullpath;

				// Get the full text content for location search (including group name)
				const fullText = card.textContent.toLowerCase();

				const matchesSearch = !searchQuery || cardNom.includes(searchQuery);
				const matchesType = !selectedType || cardType === selectedType;
				const matchesTerritoire = !selectedTerritoire || cardTerritoire === selectedTerritoire;
				const matchesLocation = !locationQuery ||
					fullText.includes(locationQuery) ||
					(cardLieu && cardLieu.includes(locationQuery)) ||
					(cardFullPath && cardFullPath.includes(locationQuery));

				const isVisible = matchesSearch && matchesType && matchesTerritoire && matchesLocation;

				if (isVisible) {
					card.style.display = 'block';
					visibleCount++;
				} else {
					card.style.display = 'none';
				}
			});

			// Update results count
			resultsCount.textContent = visibleCount;

			// Show/hide no results message
			if (visibleCount === 0) {
				document.getElementById('geoliens-grid').style.display = 'none';
				noResults.classList.remove('hidden');
			} else {
				document.getElementById('geoliens-grid').style.display = 'grid';
				noResults.classList.add('hidden');
			}
		}

		// Clear filters
		function clearFilters() {
			searchText.value = '';
			searchType.value = '';
			searchTerritoire.value = '';
			searchLocation.value = '';
			filterResults();
		}

		// Event listeners for real-time filtering
		searchText.addEventListener('input', filterResults);
		searchType.addEventListener('change', filterResults);
		searchTerritoire.addEventListener('change', filterResults);
		searchLocation.addEventListener('input', filterResults);
		clearFiltersBtn.addEventListener('click', clearFilters);

		// Initialize
		filterResults();
	</script>
</body>
</html>